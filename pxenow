#!/usr/bin/env python3

import argparse
import os
import stat
import urllib.request
import zipfile
# import errno
from netifaces import AF_INET
from shutil import copy2 as cp, which
from subprocess import call


def getfile(printable_name: str, destination_file: str, url: str, filename_in_zip: str) -> None:
	"""
	Download a zip file from the internet, extract a single file and place it somewhere.
	If filename_in_zip is the empty string, the downloaded file will be renamed/moved instead.

	:param printable_name: description of what this thing is, used to generate temporary file names and to show in messages
	:param destination_file: name of the extracted file, will be placed in tftp/boot/img/
	:param url: where to download from
	:param filename_in_zip: This will be extracted and moved to destination_file.
	:return:
	"""
	if os.path.isfile("tftp/boot/img/{0}".format(destination_file)):
		print("{0} found".format(printable_name))
	else:
		if filename_in_zip == "":
			# Not a zip file
			print("Getting {0}...".format(printable_name))
			urllib.request.urlretrieve(url, filename="tftp/boot/img/{0}".format(destination_file))
		else:
			# Zip file: download and extract
			temp_name = "pxenow-downloaded-{0}.zip".format(printable_name)

			if not os.path.isfile(temp_name):
				print("Getting {0}...".format(printable_name))
				urllib.request.urlretrieve(url, filename=temp_name)

			with zipfile.ZipFile(temp_name, "r") as zip_ref:
				print("Extracting {0}...".format(filename_in_zip))
				zipinfo = zip_ref.getinfo(filename_in_zip)
				zipinfo.filename = destination_file  # avoids extracting random folders and renaming
				zip_ref.extract(filename_in_zip, path="tftp/boot/img/")
			os.remove(temp_name)

	return


def guess_interface() -> str:
	"""
	Guess which network interface to use (= pick the only one other than lo and exit if more than one exists)

	:return: interface, e.g. enp3s0
	"""
	import netifaces

	interfaces = netifaces.interfaces()

	if 'lo' in interfaces:
		interfaces.remove('lo')

	num = len(interfaces)
	if num == 0:
		print("No interfaces found (other than loopback, possibly)")
		exit(1)
	elif num == 1:
		return interfaces[0]
	else:
		print("More than one interface: specify which one to use in " + str(interfaces))
		exit(1)


def relink(source: str, destination: str) -> None:
	"""
	Create a symlink. If something else with the same name already exists, delete and replace with symlink.

	:param source: real file (absolute path required!)
	:param destination: the link itself
	:return: None
	"""

	if os.path.islink(destination):
		current_source = os.readlink(destination)
		if current_source == source:
			return
		else:
			os.remove(destination)
	elif os.path.exists(destination):
		os.remove(destination)

	print("Creating symlink {frm} -> {to}...".format(frm=destination, to=source))
	os.symlink(source, destination)


def configure_nfs() -> None:
	print("Stopping NFS server...")
	sudocall(["systemctl", "stop", "nfs-server"])

	different = False

	try:
		with open(ETCEXPORTS, "r") as exports_file:
			old_exports = exports_file.read()
			if old_exports != exports:
				different = True
	except IOError:
		print("Cannot read {0}").format(ETCEXPORTS)
		safe_exit(8)

	if different:
		print("Saving new {0}...".format(ETCEXPORTS))
		try:
			with open(ETCEXPORTS, "w") as exports_file:
				exports_file.write(exports)
		except IOError:
			print("Cannot write {0}, re-run script as root or add the write permission temporarily".format(
				ETCEXPORTS))
			safe_exit(6)

		print("Reloading exports...")
		sudocall(["exportfs", "-a"])
	else:
		print("No need to update {0}".format(ETCEXPORTS))

	print("Starting NFS server...")
	sudocall(["systemctl", "start", "nfs-server"])
	print("")


def sudocall(what: list) -> int:
	if args.sudo:
		callme = ["sudo"]
		callme.extend(what)
		call(callme)
	else:
		return call(what)


def get_syslinux_config_for(file_name: str, mount_directory: str) -> str:
	maybe_vmlinuz = ("{0}/casper/vmlinuz".format(mount_directory), "{0}/casper/vmlinuz.efi".format(mount_directory))
	maybe_initrd = ("{0}/casper/initrd.lz".format(mount_directory), "{0}/casper/initrd".format(mount_directory))

	vmlinuz_src = search_for("vmlinuz", maybe_vmlinuz, file_name)
	initrd_src = search_for("initrd", maybe_initrd, file_name)

	vmlinuz = "mounted/{0}-vmlinuz".format(name)
	initrd = "mounted/{0}-initrd.lz".format(name)

	relink(vmlinuz_src, "tftp/boot/" + vmlinuz)
	relink(initrd_src, "tftp/boot/" + initrd)

	config = """
	LABEL -
	MENU LABEL {name} (NFS)
	TEXT HELP
	Boot with kernel+initrd from TFTP,
	and squashfs from NFS server {ip}
	ENDTEXT
	KERNEL {vmlinuz}
	APPEND root=/dev/nfs boot=casper netboot=nfs nfsroot={ip}:{mounted} initrd={initrd} ---
	""".format(name=name, ip=server, vmlinuz=vmlinuz, initrd=initrd, mounted=mount_directory)

	# TODO: re-enable if ever needed, but requires another symlink to the ISO
	# if args.memdisk:
	# 	config += """
	# LABEL -
	# MENU LABEL {name} (memdisk)
	# TEXT HELP
	# Boot from RAM, if the ISO fits
	# ENDTEXT
	# KERNEL memdisk
	# APPEND initrd=iso/{name}
	# """.format(name=name)

	return config


def search_for(what: str, where: tuple, iso_file: str) -> str:
	for maybe in where:
		if os.path.isfile(maybe):
			print("{file} found at {path}".format(file=what, path=maybe))
			return maybe
	print("{file} not found in {iso}".format(file=what, iso=iso_file))
	safe_exit(9)


def safe_exit(code: int):
	if len(mounted) > 0:
		errors = 0
		print("Unmounting all ISOs...")
		for directory in mounted:
			print("Unmounting {0}...".format(directory))
			errors += sudocall(["umount", directory])
		if errors != 0:
			print("Warning: some umount(s) failed, try stopping/restarting the NFS server and re-running the script")
	exit(code)


parser = argparse.ArgumentParser(description='Create a PXE server right here, right now.')
parser.add_argument('iso', nargs='+', type=str, help="Path to ISO images")
parser.add_argument('-i', '--interface', type=str, help="Interface to bind, e.g. enp3s0")
parser.add_argument('-n', '--netmask', type=str, help="Netmask, used only if -s is also used")
parser.add_argument('-s', '--server', type=str, help="IP address of current machine, used as TFTP, DHCP and NFS server")
# parser.add_argument('-m', '--memdisk', action='store_true', help="Generate memdisk entries for each ISO")
parser.add_argument('-N', '--nfs', action='store_true', help="Blindly overwrite /etc/exports and manage NFS server")
parser.add_argument('-S', '--sudo', action='store_true', help="Use sudo for commands that require root permissions")
parser.set_defaults(memdisk=False)
parser.set_defaults(nfs=False)
parser.set_defaults(sudo=False)
args = parser.parse_args()

mounted = []
DNSMASQCONF = "dnsmasq-pxe.conf"
SYSLINUXCONF = "tftp/boot/pxelinux.cfg/generated.conf"
ETCEXPORTS = "/etc/exports"

# Quick setting a static IP:
# IFACE=enp3s0
# ip link set "${IFACE}" up
# ip addr flush dev "${IFACE}"
# ip addr add 10.80.7.1/24 dev "${IFACE}"
# flush is necessary only if this is done over and over again (e.g. in a script like it was before)

# None is also acceptable, if server is given
interface = args.interface
netmask = "255.255.255.0"

if args.server is None:
	import netifaces

	# No IP given and no interface => we have to guess interface and obtain IP
	if interface is None:
		interface = guess_interface()

	addresses = netifaces.ifaddresses(interface)[AF_INET]

	if len(addresses) == 0:
		print("No addresses found for interface " + str(args.interface))
		safe_exit(1)

	server = addresses[0]['addr']
	netmask = addresses[0]['netmask']
else:
	if args.netmask is None:
		print("Provide a netmask if manually setting the IP, e.g. -n 255.255.255.0")
		safe_exit(7)
	server = args.server

del args.interface
del args.server

pxelinux_files = ["pxelinux.0", "lpxelinux.0", "ldlinux.c32", "menu.c32", "libutil.c32", "memdisk"]
pxelinux_files.extend(["hdt.c32", "libmenu.c32", "libcom32.c32", "libgpl.c32"])  # for HDT
pxelinux_files.extend(["reboot.c32", "poweroff.c32"])

for file in pxelinux_files:
	src = "/usr/lib/syslinux/bios/" + file
	dst = "tftp/boot/" + file
	if not os.path.isfile(dst):
		if os.path.isfile(src):
			print("Copying " + file + "...")
			cp(src, dst)
		else:
			print("Cannot find " + src)
			safe_exit(1)

pci_ids_path = "tftp/boot/" + "pci.ids"
if not os.path.isfile(pci_ids_path):
	if os.path.isfile("/usr/share/hwdata/pci.ids"):
		print("Copying pci.ids...")
		cp("/usr/share/hwdata/pci.ids", pci_ids_path)
	else:
		print("Warning: cannot find pci.ids ")

print("Generating dnsmasq configuration...")
# useful stuff: https://wiki.archlinux.org/index.php/Dnsmasq#PXE_server
dnsmasq_generated_config = ""

if interface is not None:
	dnsmasq_generated_config += """interface = {iface}
bind-interfaces
""".format(iface=interface)

dnsmasq_generated_config += """port=0
dhcp-leasefile=dnsmasq.leases

enable-tftp
tftp-root={pwd}/tftp
dhcp-option-force=66,{ip} # TFTP server

log-dhcp # More info on what's going on
dhcp-no-override # Don't put useless fields in DHCP offer
dhcp-range={ip},proxy

pxe-service=X86PC, "PXE boot NOW", boot/lpxelinux # It adds the .0 by itself
dhcp-option=vendor:PXEClient,6,2b # "kill multicast"

# These don't work in Proxy DHCP mode, apparently:
# dhcp-boot=boot/lpxelinux.0
# dhcp-option-force=209,"pxelinux.cfg/default" # PXELINUX config file (it's the default anyway)
# dhcp-option-force=210,/boot/ # PathPrefix, doesn't seem to be needed (See RFC 5071)
""".format(ip=server, pwd=os.getcwd())

with open(DNSMASQCONF, "w") as config_file:
	config_file.write(dnsmasq_generated_config)
os.chmod(DNSMASQCONF, os.stat(DNSMASQCONF).st_mode | stat.S_IROTH)

if which("dnsmasq") is None:
	print("dnsmasq binary not found in PATH")
	safe_exit(2)

result = call(["dnsmasq", "-d", "--test", "-C", DNSMASQCONF])
if result != 0:
	print("dnsmasq returned " + str(result))
	safe_exit(result)

os.makedirs("tftp/boot/iso", exist_ok=True)

getfile("Memtest86+", "memtest", "http://www.memtest.org/download/5.01/memtest86+-5.01.zip", "memtest86+-5.01.bin")
getfile("PLoP", "plpbt.bin", "https://download.plop.at/files/bootmngr/plpbt-5.0.15.zip", "plpbt-5.0.15/plpbt.bin")
getfile("netboot.xyz", "netbootxyz", "https://boot.netboot.xyz/ipxe/netboot.xyz.lkrn", "")

iso = []

if args.iso is not None:
	iso.extend(args.iso)

try:
	iso_files_found = os.listdir("iso")
	for name in iso_files_found:
		iso.append("iso/" + name)
except FileNotFoundError:
	pass

if len(iso) > 0:
	print("ISO files: {0}\n".format(str(iso)))
	os.makedirs("nfs", exist_ok=True)
	os.makedirs("tftp/boot/mounted", exist_ok=True)

syslinux_generated_config = ""

for file in iso:
	if not os.path.isfile(file):
		print("{0} doesn't exist".format(file))
		safe_exit(5)

	name = os.path.basename(file)
	mount_directory = "{pwd}/nfs/{name}.mount".format(pwd=os.getcwd(), name=name)

	if " " in mount_directory:
		print(
			"NFS path {0} contains spaces so it won't work, move everything in a directory without spaces and retry".format(
				mount_directory))
		safe_exit(6)

	os.makedirs(mount_directory, exist_ok=True)

	# Could be done "if result == 0", but if script crashes midway you'd need to unmount manually...
	mounted.append(mount_directory)

	result = sudocall(["mount", "-o", "loop,ro", "-t", "iso9660", file, mount_directory])

	if result != 0:
		print("mount returned " + str(result))
		safe_exit(result)

	print("Generating syslinux config for {0}".format(name))
	syslinux_generated_config += get_syslinux_config_for(name, mount_directory)
	print()

with open(SYSLINUXCONF, "w") as config_file:
	config_file.write(syslinux_generated_config)
os.chmod(SYSLINUXCONF, os.stat(SYSLINUXCONF).st_mode | stat.S_IROTH)

exports = ""

for full_export in mounted:
	exports += "{export} {ip}/{nm}(ro,all_squash,insecure,no_subtree_check)\n".format(export=full_export, ip=server, nm=netmask)

if exports != "":
	if args.nfs:
		configure_nfs()
	else:
		print("Almost done: add this to /etc/exports, run 'exportfs -a' and start your NFS server:")
		print("---------------------------------------------------------------------------------")
		print(exports)
		print("---------------------------------------------------------------------------------")

try:
	call(["dnsmasq", "-d", "-C", DNSMASQCONF])
except KeyboardInterrupt:
	print("Keyboard interrupt (ctrl+C) detected")

if args.nfs:
	print("Stopping NFS server...")
	sudocall(["systemctl", "stop", "nfs-server"])

safe_exit(0)
