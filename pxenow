#!/usr/bin/env python3

import argparse
import os
import stat
import urllib.request
import zipfile
# import errno
from netifaces import AF_INET
from shutil import copy2 as cp, which
from subprocess import call


def getfile(printable_name: str, destination_file: str, url: str, filename_in_zip: str) -> None:
	"""

	:param printable_name: description of what this thing is, used to generate temporary file names and to show in messages
	:param destination_file: name of the extracted file, will be placed in tftp/boot/img/
	:param url: where to download from
	:param filename_in_zip: if downloaded file is a zip, this will be extracted and moved to destination_file. Empty string if this is already the file.
	:return:
	"""
	if os.path.isfile("tftp/boot/img/{0}".format(destination_file)):
		print("{0} found".format(printable_name))
	else:
		if filename_in_zip == "":
			# Not a zip file
			print("Getting {0}...".format(printable_name))
			urllib.request.urlretrieve(url, filename="tftp/boot/img/{0}".format(destination_file))
		else:
			# Zip file: download and extract
			temp_name = "pxenow-downloaded-{0}.zip".format(printable_name)

			if not os.path.isfile(temp_name):
				print("Getting {0}...".format(printable_name))
				urllib.request.urlretrieve(url, filename=temp_name)

			with zipfile.ZipFile(temp_name, "r") as zip_ref:
				print("Extracting {0}...".format(filename_in_zip))
				zipinfo = zip_ref.getinfo(filename_in_zip)
				zipinfo.filename = destination_file  # avoids extracting random folders and renaming
				zip_ref.extract(filename_in_zip, path="tftp/boot/img/")
			os.remove(temp_name)

	return


def unmount_all(directories: list) -> None:
	"""
	:param directories: mounted directories
	"""
	print("Unmounting all ISOs...")
	for directory in directories:
		print("Unmounting {0}...".format(directory))
		call(["umount", directory])


def guess_interface() -> str:
	"""
	Guess which network interface to use (= pick the only one other than lo and exit if more than one exists)

	:return: interface, e.g. enp3s0
	"""
	import netifaces

	interfaces = netifaces.interfaces()

	if 'lo' in interfaces:
		interfaces.remove('lo')

	num = len(interfaces)
	if num == 0:
		print("No interfaces found (other than loopback, possibly)")
		exit(1)
	elif num == 1:
		return interfaces[0]
	else:
		print("More than one interface: specify which one to use in " + str(interfaces))
		exit(1)


def relink(src: str, dst: str) -> None:
	"""
	Create a symlink. If something else with the same name already exists, delete and replace with symlink.

	:param src: real file (absolute path required!)
	:param dst: the link itself
	:return: None
	"""

	if os.path.islink(dst):
		current_src = os.readlink(dst)
		if current_src == src:
			return
		else:
			os.remove(dst)
	elif os.path.exists(dst):
		os.remove(dst)

	print("Creating symlink {frm} -> {to}...".format(frm=dst, to=src))
	os.symlink(src, dst)
	# Doesn't work because filesystem is read-only (tries to modify real file permissions)
	# os.chmod(dst, os.stat(dst).st_mode | stat.S_IROTH)


parser = argparse.ArgumentParser(description='Create a PXE server right here, right now.')
# TODO: support using IP instead of interface (why did I even do this?)
parser.add_argument('-i', '--interface', type=str, help="Interface to bind, e.g. enp3s0")
parser.add_argument('-s', '--server', type=str, help="IP address of current machine, used as TFTP, DHCP and NFS server")
parser.add_argument('iso', nargs='+', type=str, help="Path to ISO images")
parser.add_argument('-m', '--memdisk', action='store_true', help="Generate memdisk entries (should work for any ISO, but it has to be loaded entirely in RAM)")
parser.set_defaults(memdisk=False)
args = parser.parse_args()

DNSMASQCONF = "dnsmasq-pxe.conf"
SYSLINUXCONF = "tftp/boot/pxelinux.cfg/generated.conf"

# Quick setting a static IP:
# IFACE=enp3s0
# ip link set "${IFACE}" up
# ip addr flush dev "${IFACE}"
# ip addr add 10.80.7.1/24 dev "${IFACE}"
# flush is necessary only if this is done over and over again (e.g. in a script like it was before)

# None is also acceptable, if server is given
interface = args.interface
netmask = "255.255.255.0" # used just as a suggestion in NFS config, not really important

if args.server is None:
	import netifaces

	# No IP given and no interface => we have to guess interface and obtain IP
	if interface is None:
		interface = guess_interface()

	addresses = netifaces.ifaddresses(interface)[AF_INET]

	if len(addresses) == 0:
		print("No addresses found for interface " + str(args.interface))
		exit(1)

	server = addresses[0]['addr']
	netmask = addresses[0]['netmask']
else:
	server = args.server

del args.interface
del args.server

pxelinux_files = ["pxelinux.0", "lpxelinux.0", "ldlinux.c32", "menu.c32", "libutil.c32", "memdisk"]
pxelinux_files.extend(["hdt.c32", "libmenu.c32", "libcom32.c32", "libgpl.c32"])  # for HDT
pxelinux_files.extend(["reboot.c32", "poweroff.c32"])

for file in pxelinux_files:
	src = "/usr/lib/syslinux/bios/" + file
	dst = "tftp/boot/" + file
	if not os.path.isfile(dst):
		if os.path.isfile(src):
			print("Copying " + file + "...")
			cp(src, dst)
		else:
			print("Cannot find " + src)
			exit(1)

pci_ids_path = "tftp/boot/" + "pci.ids"
if not os.path.isfile(pci_ids_path):
	if os.path.isfile("/usr/share/hwdata/pci.ids"):
		print("Copying pci.ids...")
		cp("/usr/share/hwdata/pci.ids", pci_ids_path)
	else:
		print("Warning: cannot find pci.ids ")

print("Generating dnsmasq configuration...")
# useful stuff: https://wiki.archlinux.org/index.php/Dnsmasq#PXE_server
dnsmasq_generated_config = ""

if interface is not None:
	dnsmasq_generated_config += """interface = {iface}
bind-interfaces
""".format(iface=interface)

dnsmasq_generated_config += """port=0
dhcp-leasefile=dnsmasq.leases

enable-tftp
tftp-root={pwd}/tftp
dhcp-option-force=66,{ip} # TFTP server

log-dhcp # More info on what's going on
dhcp-no-override # Don't put useless fields in DHCP offer
dhcp-range={ip},proxy

pxe-service=X86PC, "PXE boot NOW", boot/lpxelinux # It adds the .0 by itself
dhcp-option=vendor:PXEClient,6,2b # "kill multicast"

# These don't work in Proxy DHCP mode, apparently:
# dhcp-boot=boot/lpxelinux.0
# dhcp-option-force=209,"pxelinux.cfg/default" # PXELINUX config file (it's the default anyway)
# dhcp-option-force=210,/boot/ # PathPrefix, doesn't seem to be needed (See RFC 5071)
""".format(ip=server, pwd=os.getcwd())

with open(DNSMASQCONF, "w") as configFile:
	configFile.write(dnsmasq_generated_config)
os.chmod(DNSMASQCONF, os.stat(DNSMASQCONF).st_mode | stat.S_IROTH)

if which("dnsmasq") is None:
	print("dnsmasq binary not found in PATH")
	exit(2)

result = call(["dnsmasq", "-d", "--test", "-C", DNSMASQCONF])
if result != 0:
	print("dnsmasq returned " + str(result))
	exit(result)

os.makedirs("tftp/boot/iso", exist_ok=True)

getfile("Memtest86+", "memtest", "http://www.memtest.org/download/5.01/memtest86+-5.01.zip", "memtest86+-5.01.bin")
getfile("PLoP", "plpbt.bin", "https://download.plop.at/files/bootmngr/plpbt-5.0.15.zip", "plpbt-5.0.15/plpbt.bin")
getfile("netboot.xyz", "netbootxyz", "https://boot.netboot.xyz/ipxe/netboot.xyz.lkrn", "")

iso = []

if args.iso is not None:
	iso.extend(args.iso)

try:
	iso_files_found = os.listdir("iso")
	for name in iso_files_found:
		iso.append("iso/" + name)
except FileNotFoundError:
	pass

if len(iso) > 0:
	print("Generating syslinux conf for ISO files: {0}".format(str(iso)))
	os.makedirs("nfs", exist_ok=True)
	os.makedirs("tftp/boot/mounted", exist_ok=True)

syslinux_generated_config = ""
mounted = []

for file in iso:
	if not os.path.isfile(file):
		print("{0} doesn't exist".format(file))
		exit(5)

	name = os.path.basename(file)
	mount_directory = "{pwd}/nfs/{name}.mount".format(pwd=os.getcwd(), name=name)

	if " " in mount_directory:
		print("NFS path {0} contains spaces so it won't work, move everything in a directory without spaces and retry".format(mount_directory))
		unmount_all(mounted)
		exit(6)

	os.makedirs(mount_directory, exist_ok=True)

	# Could be done "if result == 0", but if script crashes midway you'd need to unmount manually...
	mounted.append(mount_directory)

	result = call(["mount", "-o", "loop,ro", "-t", "iso9660", file, mount_directory])

	if result != 0:
		print("mount returned " + str(result))
		unmount_all(mounted)
		exit(result)

	vmlinuz_src = "{0}/casper/vmlinuz".format(mount_directory)
	initrd_src = "{0}/casper/initrd.lz".format(mount_directory)

	vmlinuz = "mounted/{0}-vmlinuz".format(name)
	initrd = "mounted/{0}-initrd.lz".format(name)

	relink(vmlinuz_src, "tftp/boot/" + vmlinuz)
	relink(initrd_src, "tftp/boot/" + initrd)

	if args.memdisk:
		syslinux_generated_config += """
	LABEL -
	MENU LABEL {name} (memdisk)
	TEXT HELP
	Boot from RAM, if the ISO fits
	ENDTEXT
	KERNEL memdisk
	APPEND initrd=iso/{name}
	""".format(name=name)

	syslinux_generated_config += """
	LABEL -
	MENU LABEL {name} (NFS)
	TEXT HELP
	Boot with kernel+initrd from TFTP,
	and squashfs from NFS server {ip}
	ENDTEXT
	KERNEL {vmlinuz}
	APPEND root=/dev/nfs boot=casper netboot=nfs nfsroot={ip}:{mounted} initrd={initrd} ---
	""".format(name=name, ip=server, vmlinuz=vmlinuz, initrd=initrd, mounted=mount_directory)

with open(SYSLINUXCONF, "w") as configFile:
	configFile.write(syslinux_generated_config)
os.chmod(SYSLINUXCONF, os.stat(SYSLINUXCONF).st_mode | stat.S_IROTH)

print("Almost done, add this to /etc/exports, run 'exportfs -a' and start your NFS server:")
print("---------------------------------------------------------------------------------")
for full_export in mounted:
	print('{export} {ip}/{netmask}(ro,all_squash,insecure,no_subtree_check)'.format(export=full_export, ip=server, netmask=netmask))
print("---------------------------------------------------------------------------------")

try:
	call(["dnsmasq", "-d", "-C", DNSMASQCONF])
except KeyboardInterrupt:
	print("Keyboard interrupt (ctrl+C) detected")

unmount_all(mounted)
