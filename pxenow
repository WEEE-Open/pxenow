#!/usr/bin/env python3

import argparse
import netifaces
import os
import stat
import urllib.request
import zipfile
# import errno
from netifaces import AF_INET
from shutil import copy2 as cp, which
from subprocess import call


def getfile(printable_name: str, destination_file: str, url: str, filename_in_zip: str) -> None:
	if os.path.isfile(destination_file):
		print("{0} found".format(printable_name))
	else:
		temp_name = "pxenow-downloaded-{0}.zip".format(printable_name)

		if not os.path.isfile(temp_name):
			print("Getting {0}...".format(printable_name))
			urllib.request.urlretrieve(url, filename=temp_name)

		with zipfile.ZipFile(temp_name, "r") as zip_ref:
			print("Extracting {0}...".format(filename_in_zip))
			zip_ref.extract(filename_in_zip, path="tftp/boot/iso/")
			# zip_ref.extractall("tftp/boot/iso/")

		os.rename("tftp/boot/iso/{0}".format(filename_in_zip), destination_file)
		os.remove(temp_name)
	return


parser = argparse.ArgumentParser(description='Create a PXE server right here, right now.')
# TODO: support using IP instead of interface (why did I even do this?)
parser.add_argument('-i', '--interface', type=str, help="Interface to bind, e.g. enp3s0")
args = parser.parse_args()

DNSMASQCONF = "dnsmasq-pxe.conf"

interfaces = netifaces.interfaces()

# Quick setting a static IP:
# IFACE=enp3s0
# ip link set "${IFACE}" up
# ip addr flush dev "${IFACE}"
# ip addr add 10.80.7.1/24 dev "${IFACE}"
# flush is necessary only if this is done over and over again (e.g. in a script like it was before)

if args.interface is None:
	if 'lo' in interfaces:
		interfaces.remove('lo')
	num = len(interfaces)
	if num == 0:
		print("No interfaces found (other than loopback, possibly)")
		exit(1)
	elif num == 1:
		args.interface = interfaces[0]
	else:
		print("More than one interface: specify which one to use in " + str(interfaces))
		exit(1)
else:
	if args.interface not in interfaces:
		print(str(interfaces))
		print("Interface " + str(args.interface) + " doesn't exist")
		exit(1)

addresses = netifaces.ifaddresses(args.interface)[AF_INET]
if len(addresses) == 0:
	print("No addresses found for interface " + str(args.interface))
	exit(1)

server = addresses[0]['addr']
netmask = addresses[0]['netmask']

pxelinuxFiles = ("pxelinux.0", "lpxelinux.0", "ldlinux.c32", "menu.c32", "libutil.c32", "memdisk")

for file in pxelinuxFiles:
	src = "/usr/lib/syslinux/bios/" + file
	dst = "tftp/boot/" + file
	if not os.path.isfile(dst):
		if os.path.isfile(src):
			print("Copying " + file + "...")
			cp(src, dst)
		else:
			print("Cannot find " + src)
			exit(1)

print("Generating dnsmasq configuration...")
# useful stuff: https://wiki.archlinux.org/index.php/Dnsmasq#PXE_server
# dhcp-option-force=210,/arch/ ‚Üê PathPrefix doesn't seem to be needed (See RFC 5071)
dnsmasqConfig = """port=0
interface={iface}
bind-interfaces
dhcp-leasefile=dnsmasq.leases

enable-tftp
tftp-root={pwd}/tftp
dhcp-option-force=66,{ip} # TFTP server

log-dhcp # More info on what's going on
dhcp-no-override # Don't put useless fields in DHCP offer
dhcp-range={ip},proxy,{netmask}

pxe-service=X86PC, "PXE boot NOW", boot/lpxelinux # It adds the .0 by itself
dhcp-option=vendor:PXEClient,6,2b # "kill multicast"

# These don't work in Proxy DHCP mode, apparently:
# dhcp-boot=boot/lpxelinux.0
# dhcp-option-force=209,"pxelinux.cfg/default" # PXELINUX config file (it's the default anyway)
""".format(iface=args.interface, ip=server, netmask=netmask, pwd=os.getcwd())

with open(DNSMASQCONF, "w") as configFile:
	configFile.write(dnsmasqConfig)
os.chmod(DNSMASQCONF, os.stat(DNSMASQCONF).st_mode | stat.S_IROTH)

if which("dnsmasq") is None:
	print("dnsmasq binary not found in PATH")
	exit(2)

result = call(["dnsmasq", "-d", "--test", "-C", DNSMASQCONF])
if result != 0:
	print("dnsmasq returned " + str(result))
	exit(result)

os.makedirs("tftp/boot/iso", exist_ok=True)

getfile("Memtest86+", "tftp/boot/iso/memtest", "http://www.memtest.org/download/5.01/memtest86+-5.01.zip", "memtest86+-5.01.bin")
getfile("PLoP", "tftp/boot/iso/plpbt.bin", "https://download.plop.at/files/bootmngr/plpbt-5.0.15.zip", "plpbt-5.0.15/plpbt.bin")

# TODO: mount iso image (memdisk doesn't work for large images)
# TODO: and set it accessible for "others" so dnsmasq doesn't explode

# call(["dnsmasq", "-d", "-C", DNSMASQCONF])
